// Generated by CoffeeScript 2.2.2
(function() {
  var ref, ref1,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  ContentTools.Tools.RestrictedImageTool = (function() {
    class RestrictedImageTool extends ContentTools.Tools.Image {
      static apply(element, selection, callback) {
        var app, dialog, modal, toolDetail;
        // Dispatch `apply` event
        toolDetail = {
          'tool': this,
          'element': element,
          'selection': selection
        };
        if (!this.dispatchEditorEvent('tool-apply', toolDetail)) {
          return;
        }
        // If supported allow store the state for restoring once the dialog is
        // cancelled.
        if (element.storeState) {
          element.storeState();
        }
        // Set-up the dialog
        app = ContentTools.EditorApp.get();
        // Modal
        modal = new ContentTools.ModalUI();
        // Dialog
        dialog = new ContentTools.RestrictedImageDialog();
        // Support cancelling the dialog
        dialog.addEventListener('cancel', () => {
          modal.hide();
          dialog.hide();
          if (element.restoreState) {
            element.restoreState();
          }
          return callback(false);
        });
        // Support saving the dialog
        dialog.addEventListener('save', (ev) => {
          var detail, image, imageAttrs, imageSize, imageURL, index, node;
          detail = ev.detail();
          imageURL = detail.imageURL;
          imageSize = detail.imageSize;
          imageAttrs = detail.imageAttrs;
          if (!imageAttrs) {
            imageAttrs = {};
          }
          imageAttrs.height = imageSize[1];
          imageAttrs.src = imageURL;
          imageAttrs.width = imageSize[0];
          if (element.type() === 'ImageFixture') {
            // Configure the image source against the fixture
            element.src(imageURL);
          } else {
            // Create the new image
            image = new ContentEdit.Image(imageAttrs);
            // Find insert position
            [node, index] = this._insertAt(element);
            node.parent().attach(image, index);
            // Focus the new image
            image.focus();
          }
          modal.hide();
          dialog.hide();
          callback(true);
          // Dispatch `applied` event
          return this.dispatchEditorEvent('tool-applied', toolDetail);
        });
        // Show the dialog
        app.attach(modal);
        app.attach(dialog);
        modal.show();
        return dialog.show();
      }

    };

    // Register the tool with the toolshelf
    ContentTools.ToolShelf.stow(RestrictedImageTool, 'restrictedImage');

    // The tooltip and icon modifier CSS class for the tool
    RestrictedImageTool.label = 'Image';

    RestrictedImageTool.icon = 'image';

    return RestrictedImageTool;

  }).call(this);

  ref = ContentTools.RestrictedImageDialog = class RestrictedImageDialog extends ContentTools.DialogUI {
    constructor() {
      super('Select image');
      this._onImageSelect = this._onImageSelect.bind(this);
    }

    mount() {
      super.mount();
      this._addDOMEventListeners();
      if (this.constructor.IMAGE_GALLERY) {
        return this.constructor.IMAGE_GALLERY(this);
      }
    }

    setSource(imglist) {
      var domView, tags;
      tags = imglist.map(function(img) {
        var tag;
        tag = document.createElement('img');
        tag.setAttribute('src', img.src);
        return tag;
      });
      domView = this._domView;
      return tags.forEach(function(tag) {
        return domView.appendChild(tag);
      });
    }

    _addDOMEventListeners() {
      super._addDOMEventListeners();
      return this._domView.addEventListener('click', this._onImageSelect);
    }

    _onImageSelect(e) {
      var size, url;
      boundMethodCheck(this, ref);
      if (e.target.tagName.toUpperCase() === 'img'.toUpperCase()) {
        e.preventDefault();
        url = e.target.getAttribute('src');
        size = [200, 200];
        return this.save(url, size, {});
      }
    }

    save(imageURL, imageSize, imageAttrs) {
      // Save and insert the current image
      return this.dispatchEvent(this.createEvent('save', {
        'imageURL': imageURL,
        'imageSize': imageSize,
        'imageAttrs': imageAttrs
      }));
    }

    static EXAMPLE_IMAGE_GALLERY(dialog) {
      console.log('fetching imglist...');
      return setTimeout(function() {
        console.log('fetched imglist');
        return dialog.setSource([
          {
            src: 'https://www.placecage.com/gif/200/300'
          },
          {
            src: 'https://www.placecage.com/gif/200/100'
          },
          {
            src: 'https://www.placecage.com/gif/250/250'
          },
          {
            src: 'https://www.placecage.com/gif/300/200'
          },
          {
            src: 'https://www.placecage.com/gif/400/400'
          },
          {
            src: 'https://www.placecage.com/gif/200/200'
          }
        ]);
      }, 1 * 1000);
    }

  };

  ContentTools.Tools.RestrictedLinkTool = (function() {
    class RestrictedLinkTool extends ContentTools.Tools.Bold {
      static getAttr(attrName, element, selection) {
        var c, from, i, j, len, len1, ref1, ref2, selectedContent, tag, to;
        // Get an attribute for the element and selection

        // Images
        if (element.type() === 'Image') {
          if (element.a) {
            return element.a[attrName];
          }
        // Fixtures
        } else if (element.isFixed() && element.tagName() === 'a') {
          return element.attr(attrName);
        } else {
          // Find the first character in the selected text that has an `a` tag
          // and return the named attributes value.
          // Text
          [from, to] = selection.get();
          selectedContent = element.content.slice(from, to);
          ref1 = selectedContent.characters;
          for (i = 0, len = ref1.length; i < len; i++) {
            c = ref1[i];
            if (!c.hasTags('a')) {
              continue;
            }
            ref2 = c.tags();
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              tag = ref2[j];
              if (tag.name() === 'a') {
                return tag.attr(attrName);
              }
            }
          }
        }
        return '';
      }

      static canApply(element, selection) {
        var character;
        // Return true if the tool can be applied to the current
        // element/selection.
        if (element.type() === 'Image') {
          return true;
        } else if (element.isFixed() && element.tagName() === 'a') {
          return true;
        } else {
          // Must support content
          if (!element.content) {
            return false;
          }
          // A selection must exist
          if (!selection) {
            return false;
          }
          // If the selection is collapsed then it must be within an existing
          // link.
          if (selection.isCollapsed()) {
            character = element.content.characters[selection.get()[0]];
            if (!character || !character.hasTags('a')) {
              return false;
            }
          }
          return true;
        }
      }

      static isApplied(element, selection) {
        // Return true if the tool is currently applied to the current
        // element/selection.
        if (element.type() === 'Image') {
          return element.a;
        } else if (element.isFixed() && element.tagName() === 'a') {
          return true;
        } else {
          return super.isApplied(element, selection);
        }
      }

      static apply(element, selection, callback) {
        var allowScrolling, app, applied, characters, dialog, domElement, ends, from, measureSpan, modal, rect, scrollX, scrollY, selectTag, starts, to, toolDetail, transparent;
        // Dispatch `apply` event
        toolDetail = {
          'tool': this,
          'element': element,
          'selection': selection
        };
        if (!this.dispatchEditorEvent('tool-apply', toolDetail)) {
          return;
        }
        applied = false;
        // Prepare text elements for adding a link
        if (element.type() === 'Image') {
          // Images
          rect = element.domElement().getBoundingClientRect();
        } else if (element.isFixed() && element.tagName() === 'a') {
          // Fixtures
          rect = element.domElement().getBoundingClientRect();
        } else {
          // If the selection is collapsed then we need to select the entire
          // entire link.
          if (selection.isCollapsed()) {
            // Find the bounds of the link
            characters = element.content.characters;
            starts = selection.get(0)[0];
            ends = starts;
            while (starts > 0 && characters[starts - 1].hasTags('a')) {
              starts -= 1;
            }
            while (ends < characters.length && characters[ends].hasTags('a')) {
              ends += 1;
            }
            // Select the link in full
            selection = new ContentSelect.Range(starts, ends);
            selection.select(element.domElement());
          }
          // Text elements
          element.storeState();
          // Add a fake selection wrapper to the selected text so that it
          // appears to be selected when the focus is lost by the element.
          selectTag = new HTMLString.Tag('span', {
            'class': 'ct--puesdo-select'
          });
          [from, to] = selection.get();
          element.content = element.content.format(from, to, selectTag);
          element.updateInnerHTML();
          // Measure a rectangle of the content selected so we can position the
          // dialog centrally.
          domElement = element.domElement();
          measureSpan = domElement.getElementsByClassName('ct--puesdo-select');
          rect = measureSpan[0].getBoundingClientRect();
        }
        // Set-up the dialog
        app = ContentTools.EditorApp.get();
        // Modal
        modal = new ContentTools.ModalUI(transparent = true, allowScrolling = true);
        // When the modal is clicked on the dialog should close
        modal.addEventListener('click', function() {
          this.unmount();
          dialog.hide();
          if (element.content) {
            // Remove the fake selection from the element
            element.content = element.content.unformat(from, to, selectTag);
            element.updateInnerHTML();
            // Restore the selection
            element.restoreState();
          }
          callback(applied);
          // Dispatch `applied` event
          if (applied) {
            return ContentTools.Tools.Link.dispatchEditorEvent('tool-applied', toolDetail);
          }
        });
        // Dialog
        dialog = new ContentTools.RestrictedLinkDialog(this.getAttr('href', element, selection), this.getAttr('target', element, selection));
        // Get the scroll position required for the dialog
        [scrollX, scrollY] = ContentTools.getScrollPosition();
        // dialog.position([
        //     rect.left + (rect.width / 2) + scrollX,
        //     rect.top + (rect.height / 2) + scrollY
        //     ])
        dialog.addEventListener('save', function(ev) {
          var a, alignmentClassNames, className, detail, i, j, len, len1, linkClasses;
          detail = ev.detail();
          applied = true;
          // Add the link
          if (element.type() === 'Image') {
            // Images

            // Note: When we add/remove links any alignment class needs to be
            // moved to either the link (on adding a link) or the image (on
            // removing a link). Alignment classes are mutually exclusive.
            alignmentClassNames = ['align-center', 'align-left', 'align-right'];
            if (detail.href) {
              element.a = {
                href: detail.href
              };
              if (element.a) {
                element.a.class = element.a['class'];
              }
              if (detail.target) {
                element.a.target = detail.target;
              }
              for (i = 0, len = alignmentClassNames.length; i < len; i++) {
                className = alignmentClassNames[i];
                if (element.hasCSSClass(className)) {
                  element.removeCSSClass(className);
                  element.a['class'] = className;
                  break;
                }
              }
            } else {
              linkClasses = [];
              if (element.a['class']) {
                linkClasses = element.a['class'].split(' ');
              }
              for (j = 0, len1 = alignmentClassNames.length; j < len1; j++) {
                className = alignmentClassNames[j];
                if (linkClasses.indexOf(className) > -1) {
                  element.addCSSClass(className);
                  break;
                }
              }
              element.a = null;
            }
            element.unmount();
            element.mount();
          } else if (element.isFixed() && element.tagName() === 'a') {
            // Fixtures
            element.attr('href', detail.href);
          } else {
            // Text elements

            // Clear any existing link
            element.content = element.content.unformat(from, to, 'a');
            // If specified add the new link
            if (detail.href) {
              a = new HTMLString.Tag('a', detail);
              element.content = element.content.format(from, to, a);
              element.content.optimize();
            }
            element.updateInnerHTML();
          }
          // Make sure the element is marked as tainted
          element.taint();
          // Close the modal and dialog
          return modal.dispatchEvent(modal.createEvent('click'));
        });
        app.attach(modal);
        app.attach(dialog);
        modal.show();
        return dialog.show();
      }

    };

    // Insert/Remove a link.
    ContentTools.ToolShelf.stow(RestrictedLinkTool, 'restrictedLink');

    RestrictedLinkTool.label = 'Link';

    RestrictedLinkTool.icon = 'link';

    RestrictedLinkTool.tagName = 'a';

    return RestrictedLinkTool;

  }).call(this);

  ref1 = ContentTools.RestrictedLinkDialog = (function() {
    var NEW_WINDOW_TARGET;

    class RestrictedLinkDialog extends ContentTools.DialogUI {
      constructor(href = '', target = '') {
        super();
        this.setSource = this.setSource.bind(this);
        // The initial value to set the href and target attribute
        // of the link as (e.g if we're editing a link).
        this._href = href;
        this._target = target;
      }

      mount() {
        // Mount the widget
        super.mount();
        // Create the input element for the link
        this._domInput = document.createElement('input');
        this._domInput.setAttribute('class', 'ct-anchored-dialog__input');
        this._domInput.setAttribute('name', 'href');
        this._domInput.setAttribute('placeholder', ContentEdit._('Enter a link') + '...');
        this._domInput.setAttribute('type', 'text');
        this._domInput.setAttribute('value', this._href);
        // @_domElement.appendChild(@_domInput)

        // Create a toggle button to allow users to toogle between no target and
        // TARGET (open in a new window).
        this._domTargetButton = this.constructor.createDiv(['ct-anchored-dialog__target-button']);
        // @_domElement.appendChild(@_domTargetButton)

        // Check if the new window target has already been set for the link
        if (this._target === NEW_WINDOW_TARGET) {
          ContentEdit.addCSSClass(this._domTargetButton, 'ct-anchored-dialog__target-button--active');
        }
        // Create the confirm button
        this._domButton = this.constructor.createDiv(['ct-anchored-dialog__button']);
        // @_domElement.appendChild(@_domButton)

        // Add interaction handlers
        this._addDOMEventListeners();
        if (this.constructor.LINK_LIST) {
          return this.constructor.LINK_LIST(this);
        }
      }

      save(value) {
        var detail;
        // Save the link. This method triggers the save method against the dialog
        // allowing the calling code to listen for the `save` event and manage
        // the outcome.
        if (!this.isMounted()) {
          this.dispatchEvent(this.createEvent('save'));
          return;
        }
        detail = {
          href: value
        };
        if (this._target) {
          detail.target = this._target;
        }
        return this.dispatchEvent(this.createEvent('save', detail));
      }

      show() {
        // Show the widget
        super.show();
        // Once visible automatically give focus to the link input
        this._domInput.focus();
        // If a there's an intially value then select it so it can be easily
        // replaced.
        if (this._href) {
          return this._domInput.select();
        }
      }

      unmount() {
        // Unmount the component from the DOM

        // Unselect any content
        if (this.isMounted()) {
          this._domInput.blur();
        }
        super.unmount();
        this._domButton = null;
        return this._domInput = null;
      }

      // Private methods
      _addDOMEventListeners() {
        // Add event listeners for the widget

        // Add support for saving the link whenever the `return` key is pressed
        // or the button is selected.

        // Input
        this._domInput.addEventListener('keypress', (ev) => {
          if (ev.keyCode === 13) {
            return this.save();
          }
        });
        // Toggle the target attribute for the link ('' or TARGET)
        this._domTargetButton.addEventListener('click', (ev) => {
          ev.preventDefault();
          // No target
          if (this._target === NEW_WINDOW_TARGET) {
            this._target = '';
            return ContentEdit.removeCSSClass(this._domTargetButton, 'ct-anchored-dialog__target-button--active');
          } else {
            // Target TARGET
            this._target = NEW_WINDOW_TARGET;
            return ContentEdit.addCSSClass(this._domTargetButton, 'ct-anchored-dialog__target-button--active');
          }
        });
        // Button
        this._domButton.addEventListener('click', (ev) => {
          ev.preventDefault();
          return this.save();
        });
        return this._domView.addEventListener('click', (ev) => {
          var target;
          if (ev.target.className.indexOf('link-button') === -1) {
            return;
          }
          ev.preventDefault();
          target = ev.target.getAttribute('data-target');
          return this.save(target);
        });
      }

      setSource(links) {
        var domView, linkNodes;
        boundMethodCheck(this, ref1);
        domView = this._domView;
        return linkNodes = (links || []).map((link) => {
          var domButton, row, text;
          row = document.createElement("div");
          text = document.createElement("span");
          text.innerHTML = link;
          row.appendChild(text);
          domButton = this.constructor.createDiv(['ct-anchored-dialog__button link-button']);
          domButton.setAttribute('data-target', link);
          row.appendChild(domButton);
          return row;
        }).forEach(function(node) {
          return domView.appendChild(node);
        });
      }

      static EXAMPLE_LINK_LIST(dialog) {
        console.log('fetching links...');
        return setTimeout(function() {
          console.log('fetched links');
          return dialog.setSource(['https://www.placecage.com/gif/200/300']);
        }, 1 * 1000);
      }

    };

    // An anchored dialog to support inserting/modifying a link

    // The target that will be set by the link tool if the open in new window
    // option is selected.
    NEW_WINDOW_TARGET = '_blank';

    return RestrictedLinkDialog;

  }).call(this);

}).call(this);

//# sourceMappingURL=restrictedTools.js.map
